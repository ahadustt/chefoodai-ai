"""
Recipe generation routes
AI-powered recipe creation and management endpoints
"""

import time
from typing import Optional

from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends
from fastapi.responses import JSONResponse
import structlog

from config import get_settings
from ..models import (
    RecipeGenerationRequest, 
    RecipeGenerationResponse,
    Recipe,
    ErrorResponse,
    ErrorType,
    ResponseStatus,
    DifficultyLevel,
    CuisineType,
    DietaryRestriction,
    NutritionInfo
)

logger = structlog.get_logger()
router = APIRouter(prefix="/api/v1/recipes", tags=["Recipe Generation"])


# Initialize AI services (with fallback handling)
vertex_ai = None
recipe_generator = None

try:
    from ai.vertex_integration import VertexAIService
    settings = get_settings()
    vertex_ai = VertexAIService(
        project_id=settings.google_cloud_project,
        location=settings.vertex_ai_location
    )
    logger.info("Vertex AI service initialized for recipes")
except Exception as e:
    logger.warning("Failed to initialize Vertex AI service", error=str(e))

try:
    from ai.recipe_generator import RecipeGenerator
    if vertex_ai:
        recipe_generator = RecipeGenerator(vertex_ai)
        logger.info("Recipe generator initialized")
except Exception as e:
    logger.warning("Failed to initialize recipe generator", error=str(e))


async def generate_fallback_recipe(request: RecipeGenerationRequest) -> Recipe:
    """Generate a fallback recipe when AI services are unavailable"""
    
    # Create a basic recipe structure based on the request
    base_ingredients = [
        "2 cups all-purpose flour",
        "1 tsp salt", 
        "2 tbsp olive oil",
        "1 cup water"
    ]
    
    if request.ingredients:
        base_ingredients.extend([f"1 cup {ingredient}" for ingredient in request.ingredients[:3]])
    
    cuisine_instructions = {
        CuisineType.ITALIAN: [
            "Combine flour and salt in a large bowl",
            "Add olive oil and water gradually", 
            "Knead the dough until smooth",
            "Let rest for 30 minutes",
            "Roll out and cut into desired shapes",
            "Cook in boiling salted water until tender"
        ],
        CuisineType.MEXICAN: [
            "Mix dry ingredients in a bowl",
            "Add oil and warm water",
            "Knead until smooth dough forms",
            "Cover and rest for 20 minutes", 
            "Roll into tortillas",
            "Cook on hot griddle until spotted"
        ]
    }
    
    instructions = cuisine_instructions.get(
        request.cuisine, 
        [
            "Prepare all ingredients according to recipe",
            "Combine ingredients in order specified",
            "Cook according to temperature and timing guidelines",
            "Season to taste and serve hot"
        ]
    )
    
    # Basic nutrition estimation
    nutrition = NutritionInfo(
        calories=350.0,
        protein=12.0,
        carbs=45.0,
        fat=8.0,
        fiber=3.0,
        sodium=400.0
    )
    
    return Recipe(
        title=f"AI Generated {request.cuisine.value.title() if request.cuisine else 'Fusion'} Recipe",
        description="A delicious recipe generated by our AI system",
        ingredients=base_ingredients,
        instructions=instructions,
        prep_time=15,
        cook_time=30,
        total_time=45,
        servings=request.servings,
        difficulty=request.difficulty,
        cuisine=request.cuisine,
        dietary_restrictions=request.dietary_restrictions,
        nutrition=nutrition,
        tags=["ai-generated", "fallback"]
    )


@router.post("/generate", response_model=RecipeGenerationResponse)
async def generate_recipe(
    request: RecipeGenerationRequest,
    background_tasks: BackgroundTasks
):
    """
    Generate a recipe using AI
    
    Creates a custom recipe based on the provided prompt, cuisine preferences,
    dietary restrictions, and other parameters.
    """
    start_time = time.time()
    request_id = None
    
    try:
        logger.info(
            "Recipe generation started",
            prompt=request.prompt[:100],  # Log first 100 chars
            cuisine=request.cuisine,
            servings=request.servings,
            difficulty=request.difficulty
        )
        
        # Validate request
        if len(request.prompt.strip()) < 3:
            raise HTTPException(
                status_code=422,
                detail="Prompt must be at least 3 characters long"
            )
        
        recipe = None
        model_used = "fallback"
        
        # Try to use the AI service
        if recipe_generator:
            try:
                # Use the actual recipe generator
                ai_recipe = await recipe_generator.generate(
                    prompt=request.prompt,
                    cuisine=request.cuisine.value if request.cuisine else None,
                    dietary_restrictions=[dr.value for dr in request.dietary_restrictions],
                    servings=request.servings,
                    difficulty=request.difficulty.value,
                    max_time=request.max_time,
                    ingredients=request.ingredients,
                    user_preferences=request.user_preferences,
                    temperature=request.temperature or get_settings().temperature
                )
                
                # Convert AI response to our Recipe model
                recipe = Recipe(
                    title=ai_recipe.get("title", "AI Generated Recipe"),
                    description=ai_recipe.get("description"),
                    ingredients=ai_recipe.get("ingredients", []),
                    instructions=ai_recipe.get("instructions", []),
                    prep_time=ai_recipe.get("prep_time"),
                    cook_time=ai_recipe.get("cook_time"),
                    total_time=ai_recipe.get("total_time"),
                    servings=request.servings,
                    difficulty=request.difficulty,
                    cuisine=request.cuisine,
                    dietary_restrictions=request.dietary_restrictions,
                    nutrition=NutritionInfo(**ai_recipe.get("nutrition", {})) if ai_recipe.get("nutrition") else None,
                    tags=ai_recipe.get("tags", [])
                )
                model_used = get_settings().default_model
                
            except Exception as e:
                logger.warning("AI recipe generation failed, using fallback", error=str(e))
                recipe = await generate_fallback_recipe(request)
                model_used = "fallback"
        else:
            # Use fallback recipe generation
            recipe = await generate_fallback_recipe(request)
        
        processing_time = time.time() - start_time
        
        # Log successful generation
        logger.info(
            "Recipe generation completed",
            recipe_title=recipe.title,
            model_used=model_used,
            processing_time=round(processing_time, 3)
        )
        
        # Create response
        response = RecipeGenerationResponse(
            recipe=recipe,
            model_used=model_used,
            processing_time=round(processing_time, 3)
        )
        
        # Add background task for analytics/caching if needed
        background_tasks.add_task(
            log_recipe_generation_analytics,
            request=request,
            response=response,
            processing_time=processing_time
        )
        
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        processing_time = time.time() - start_time
        
        logger.error(
            "Recipe generation failed",
            error=str(e),
            error_type=type(e).__name__,
            processing_time=round(processing_time, 3)
        )
        
        # Return standardized error response
        error_response = ErrorResponse(
            error_type=ErrorType.INTERNAL_ERROR,
            detail=f"Recipe generation failed: {str(e)}",
            request_id=request_id
        )
        
        return JSONResponse(
            status_code=500,
            content=error_response.dict()
        )


@router.get("/cuisines")
async def get_supported_cuisines():
    """
    Get list of supported cuisine types
    """
    cuisines = [
        {
            "value": cuisine.value,
            "name": cuisine.value.replace('_', ' ').title(),
            "description": f"Traditional {cuisine.value.replace('_', ' ')} cuisine"
        }
        for cuisine in CuisineType
    ]
    
    return {
        "cuisines": cuisines,
        "total": len(cuisines)
    }


@router.get("/dietary-restrictions")
async def get_dietary_restrictions():
    """
    Get list of supported dietary restrictions
    """
    restrictions = [
        {
            "value": restriction.value,
            "name": restriction.value.replace('_', ' ').title(),
            "description": f"Recipes suitable for {restriction.value.replace('_', ' ')} diet"
        }
        for restriction in DietaryRestriction
    ]
    
    return {
        "dietary_restrictions": restrictions,
        "total": len(restrictions)
    }


@router.get("/difficulty-levels")
async def get_difficulty_levels():
    """
    Get list of recipe difficulty levels
    """
    levels = [
        {
            "value": level.value,
            "name": level.value.title(),
            "description": f"{level.value.title()} level recipe"
        }
        for level in DifficultyLevel
    ]
    
    return {
        "difficulty_levels": levels,
        "total": len(levels)
    }


@router.post("/enhance")
async def enhance_recipe(recipe_data: dict):
    """
    Enhance an existing recipe with AI suggestions
    """
    try:
        # This would integrate with AI enhancement services
        enhanced_recipe = {
            **recipe_data,
            "enhanced": True,
            "suggestions": [
                "Consider adding fresh herbs for extra flavor",
                "Try marinating the protein for better taste",
                "Add a complementary side dish"
            ],
            "wine_pairing": "A light white wine would complement this dish",
            "cooking_tips": [
                "Ensure all ingredients are at room temperature",
                "Don't overcook the vegetables to maintain texture"
            ]
        }
        
        return {
            "status": ResponseStatus.SUCCESS,
            "enhanced_recipe": enhanced_recipe,
            "enhancements_applied": [
                "flavor_suggestions",
                "wine_pairing", 
                "cooking_tips"
            ]
        }
        
    except Exception as e:
        logger.error("Recipe enhancement failed", error=str(e))
        return JSONResponse(
            status_code=500,
            content={
                "status": ResponseStatus.ERROR,
                "detail": f"Recipe enhancement failed: {str(e)}"
            }
        )


async def log_recipe_generation_analytics(
    request: RecipeGenerationRequest, 
    response: RecipeGenerationResponse,
    processing_time: float
):
    """Background task to log analytics for recipe generation"""
    try:
        analytics_data = {
            "timestamp": time.time(),
            "cuisine": request.cuisine.value if request.cuisine else None,
            "dietary_restrictions": [dr.value for dr in request.dietary_restrictions],
            "servings": request.servings,
            "difficulty": request.difficulty.value,
            "model_used": response.model_used,
            "processing_time": processing_time,
            "success": True
        }
        
        # In a real implementation, this would save to analytics database
        logger.info("Recipe generation analytics", **analytics_data)
        
    except Exception as e:
        logger.warning("Failed to log recipe analytics", error=str(e))